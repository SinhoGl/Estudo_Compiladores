\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}

\geometry{left=3cm,right=2cm,top=3cm,bottom=2cm}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Trabalho Prático - Compiladores}
\fancyfoot[C]{\thepage}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    xleftmargin=2em,
    framexleftmargin=1.5em
}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \textbf{\Large UNIVERSIDADE ESTADUAL DO}\\
        \textbf{\Large SUDOESTE DA BAHIA}\\
        \textbf{\Large DEPARTAMENTO DE CIÊNCIAS EXATAS E TECNOLÓGICAS}\\
        \textbf{\Large CURSO DE CIÊNCIA DA COMPUTAÇÃO}
        
        \vspace{2cm}
        
        \textbf{\Large TRABALHO PRÁTICO}\\
        \vspace{0.5cm}
        \textbf{\LARGE ANALISADOR SINTÁTICO}\\
        \textbf{\Large PARA LINGUAGEM SIGMA-}
        
        \vspace{1.5cm}
        
        \textbf{Implementação de Analisador Sintático Descendente Recursivo}\\
        \textbf{com Interface Gráfica}
        
        \vfill
        
        \textbf{Autores:}\\
        Gleison Silva de Souza\\
        Guilherme Oliveira Araujo
        
        
        \vspace{1cm}
        
        \textbf{Professor:} José Carlos Martins Oliveira\\
        \textbf{Disciplina:} Compiladores
        
        \vspace{1cm}
        
        Vitória da Conquista -- BA\\
        Novembro de 2025
        
    \end{center}
\end{titlepage}

\newpage

\section*{Resumo}

Este trabalho apresenta a implementação completa de um analisador sintático para a linguagem Sigma-, desenvolvido como parte da disciplina de Compiladores. O analisador utiliza a técnica de análise descendente recursiva (top-down parsing) e implementa uma gramática livre de contexto com 14 não-terminais (S, D, V, T, I, L, C, A, R, W, F, G, M, N, P, E, B). O sistema foi desenvolvido em Python 3.12 e inclui uma interface gráfica intuitiva desenvolvida com Tkinter, permitindo visualização hierárquica da árvore sintática gerada. A implementação contempla análise léxica integrada, tratamento de erros sintáticos com mensagens descritivas e geração de árvore de derivação no formato visual com conectores hierárquicos. O trabalho demonstra a eficácia da técnica de análise descendente recursiva para gramáticas simples, alcançando análise sintática completa e correta de programas escritos na linguagem Sigma-. São apresentados resultados de testes exaustivos com 5 programas-exemplo cobrindo diferentes construções da linguagem, incluindo declarações de variáveis, estruturas de controle, operações aritméticas e comandos de entrada/saída.

\textbf{Palavras-chave:} Compiladores, Análise Sintática, Gramática Livre de Contexto, Parser Descendente Recursivo, Linguagem Sigma-, Árvore de Derivação.

\newpage

\tableofcontents

\newpage

\section{Introdução}

\subsection{Contexto e Motivação}

A análise sintática é uma etapa fundamental no processo de compilação, responsável por verificar se a sequência de tokens gerados pelo analisador léxico está em conformidade com a gramática da linguagem de programação. Este trabalho implementa um analisador sintático completo para a linguagem Sigma-, uma linguagem educacional do tipo Pascal simplificada, desenvolvida especificamente para o ensino de conceitos de compiladores.

A linguagem Sigma- foi projetada com características suficientes para demonstrar os principais conceitos de análise sintática, incluindo declaração de variáveis, estruturas de controle (condicionais e repetição), expressões aritméticas com precedência de operadores e comandos de entrada/saída. Esta simplicidade intencional permite focar nos aspectos fundamentais da análise sintática sem a complexidade de linguagens reais de produção.

\subsection{Objetivos}

Este trabalho tem como objetivos principais:

\begin{enumerate}
    \item Implementar um analisador sintático descendente recursivo completo para a linguagem Sigma-
    \item Desenvolver uma interface gráfica intuitiva para visualização do processo de análise
    \item Gerar árvores sintáticas hierárquicas que demonstrem claramente a estrutura do programa analisado
    \item Implementar tratamento de erros sintáticos com mensagens descritivas e informativas
    \item Validar a implementação através de um conjunto abrangente de programas-teste
    \item Documentar detalhadamente o processo de desenvolvimento e as decisões de projeto
\end{enumerate}

\subsection{Estrutura do Documento}

Este documento está organizado da seguinte forma: a Seção 2 descreve a gramática da linguagem Sigma- e suas características; a Seção 3 apresenta a metodologia de implementação e as tecnologias utilizadas; a Seção 4 detalha a arquitetura do sistema; a Seção 5 apresenta os resultados dos testes realizados; a Seção 6 discute as limitações e possíveis melhorias; e a Seção 7 conclui o trabalho apresentando as principais contribuições e aprendizados.

\section{Descrição da Linguagem Sigma-}

\subsection{Gramática Formal}

A linguagem Sigma- é definida por uma gramática livre de contexto composta por 14 não-terminais. A gramática foi projetada para ser não-ambígua e adequada para análise descendente recursiva (LL). A seguir, apresentamos a gramática completa na notação BNF:

\begin{align*}
S &\to \text{program id; D begin L end.} \mid \text{program id; begin L end.} \\
D &\to \text{var V} \\
V &\to \text{I : T; V} \mid \text{I : T;} \\
T &\to \text{integer} \mid \text{boolean} \\
I &\to \text{id} \mid \text{id, I} \\
L &\to \text{C;} \mid \text{C; L} \\
C &\to A \mid R \mid W \mid M \mid N \mid P \\
A &\to \text{id := E} \\
R &\to \text{read(I)} \mid \text{readln} \mid \text{readln(I)} \\
W &\to \text{write(F)} \mid \text{writeln} \mid \text{writeln(F)} \\
F &\to G \mid \text{G, F} \\
G &\to \text{str} \mid E \\
M &\to \text{begin L end} \\
N &\to \text{if B then C} \mid \text{if B then C else C} \\
P &\to \text{while B do C} \\
E &\to E + E \mid E - E \mid E * E \mid E / E \mid -E \mid (E) \mid \text{id} \mid \text{num} \\
B &\to E < E \mid E \leq E \mid E > E \mid E \geq E \mid E = E \mid E \neq E \mid \text{id}
\end{align*}

\subsection{Significado dos Não-Terminais}

A Tabela 1 apresenta o significado de cada não-terminal na gramática:

\begin{table}[h]
\centering
\caption{Significado dos Não-Terminais da Gramática Sigma-}
\begin{tabular}{|c|l|}
\hline
\textbf{Símbolo} & \textbf{Significado} \\
\hline
S & Programa completo \\
D & Declarações de variáveis \\
V & Lista de variáveis \\
T & Tipo de dados (integer ou boolean) \\
I & Lista de identificadores \\
L & Lista de comandos \\
C & Comando \\
A & Atribuição \\
R & Comando de leitura (read/readln) \\
W & Comando de escrita (write/writeln) \\
F & Lista de saída (strings e expressões) \\
G & Item de saída (string ou expressão) \\
M & Bloco composto (begin...end) \\
N & Condicional (if...then...else) \\
P & Repetição (while...do) \\
E & Expressão aritmética \\
B & Expressão booleana \\
\hline
\end{tabular}
\end{table}

\subsection{Características da Linguagem}

A linguagem Sigma- possui as seguintes características:

\subsubsection{Palavras Reservadas}

\texttt{program, var, integer, boolean, begin, end, read, readln, write, writeln, if, then, else, while, do}

\subsubsection{Operadores}

\begin{itemize}
    \item \textbf{Aritméticos:} \texttt{+, -, *, /}
    \item \textbf{Relacionais:} \texttt{<, <=, >, >=, =, <>}
    \item \textbf{Atribuição:} \texttt{:=}
\end{itemize}

\subsubsection{Delimitadores}

\texttt{;, ,, :, (, ), .}

\subsubsection{Comentários}

Comentários são delimitados por chaves: \texttt{\{comentário\}}

\subsection{Exemplo de Programa Válido}

\begin{lstlisting}[caption=Exemplo de programa em Sigma-]
program exemplo;
var x, y, resultado : integer;
begin
  readln(x, y);
  resultado := (x + y) * 2;
  if resultado > 100 then
    writeln("Grande")
  else
    writeln("Pequeno")
end.
\end{lstlisting}

\section{Metodologia e Implementação}

\subsection{Ambiente de Desenvolvimento}

A Tabela 2 apresenta as especificações do ambiente utilizado no desenvolvimento:

\begin{table}[h]
\centering
\caption{Especificações do Ambiente de Desenvolvimento}
\begin{tabular}{|l|l|}
\hline
\textbf{Componente} & \textbf{Especificação} \\
\hline
Sistema Operacional & Windows 11 \\
Linguagem & Python 3.12 \\
IDE & Visual Studio Code \\
Biblioteca GUI & Tkinter 8.6 \\
Memória RAM & 16 GB \\
\hline
\end{tabular}
\end{table}

\subsection{Técnica de Análise Sintática}

Foi escolhida a técnica de \textbf{análise descendente recursiva} (recursive descent parsing) pelos seguintes motivos:

\begin{enumerate}
    \item \textbf{Simplicidade de implementação:} Cada não-terminal da gramática é implementado como uma função Python, tornando o código intuitivo e fácil de manter
    \item \textbf{Adequação à gramática:} A gramática Sigma- é não-ambígua e adequada para análise LL(1)
    \item \textbf{Facilidade de depuração:} A correspondência direta entre gramática e código facilita identificação e correção de erros
    \item \textbf{Extensibilidade:} Novas construções podem ser adicionadas facilmente através de novas funções
\end{enumerate}

\subsection{Estratégia de Tratamento de Precedência}

Para expressões aritméticas, foi necessário eliminar a recursão à esquerda e implementar precedência de operadores. A gramática original:

\begin{align*}
E &\to E + E \mid E - E \mid E * E \mid E / E \mid -E \mid (E) \mid \text{id} \mid \text{num}
\end{align*}

Foi transformada em:

\begin{align*}
E &\to T \; E' \\
E' &\to + T \; E' \mid - T \; E' \mid \varepsilon \\
T &\to F \; T' \\
T' &\to * F \; T' \mid / F \; T' \mid \varepsilon \\
F &\to -F \mid (E) \mid \text{id} \mid \text{num}
\end{align*}

Esta transformação garante que multiplicação e divisão tenham precedência sobre adição e subtração, conforme esperado em linguagens de programação convencionais.

\section{Arquitetura do Sistema}

\subsection{Visão Geral}

O sistema é composto por três módulos principais:

\begin{enumerate}
    \item \textbf{Analisador Léxico (Lexer):} Responsável pela tokenização do código-fonte
    \item \textbf{Analisador Sintático (Parser):} Implementa a análise descendente recursiva
    \item \textbf{Interface Gráfica (GUI):} Permite interação com o usuário e visualização dos resultados
\end{enumerate}

\subsection{Módulo de Análise Léxica}

O analisador léxico foi implementado na classe \texttt{Lexer} e é responsável por:

\begin{itemize}
    \item Identificar palavras-chave, identificadores, números e strings
    \item Reconhecer operadores e delimitadores
    \item Ignorar comentários e espaços em branco
    \item Tratar quebras de linha
    \item Gerar tokens com informações de linha e coluna
\end{itemize}

\subsubsection{Estrutura do Token}

Cada token contém:

\begin{lstlisting}[caption=Estrutura do Token]
class Token:
    def __init__(self, token_type, value, line, column):
        self.type = token_type      # Tipo do token
        self.value = value          # Valor literal
        self.line = line            # Linha no código
        self.column = column        # Coluna no código
\end{lstlisting}

\subsection{Módulo de Análise Sintática}

O analisador sintático implementa cada produção da gramática como um método Python. A estratégia geral é:

\begin{enumerate}
    \item \textbf{Método \texttt{peek()}:} Visualiza o token atual sem consumi-lo
    \item \textbf{Método \texttt{advance()}:} Consome o token atual e avança para o próximo
    \item \textbf{Método \texttt{expect(tipo)}:} Verifica se o token atual é do tipo esperado
    \item \textbf{Construção da árvore:} Cada método retorna um nó da árvore sintática
\end{enumerate}

\subsubsection{Exemplo de Implementação}

\begin{lstlisting}[caption=Exemplo de método de parsing]
def parse_A(self):
    """A -> id := E"""
    node = TreeNode("A")
    
    # Espera identificador
    id_token = self.expect(TokenType.IDENTIFIER)
    node.add_child(TreeNode("id", token=id_token))
    
    # Espera operador de atribuição
    assign_token = self.expect(TokenType.ASSIGN)
    node.add_child(TreeNode(":=", token=assign_token))
    
    # Parseia expressão
    node.add_child(self.parse_E())
    
    return node
\end{lstlisting}

\subsection{Representação da Árvore Sintática}

A árvore sintática é representada através da classe \texttt{TreeNode}:

\begin{lstlisting}[caption=Estrutura do Nó da Árvore]
class TreeNode:
    def __init__(self, symbol, token=None, children=None):
        self.symbol = symbol      # Símbolo (S, D, V, ...)
        self.token = token        # Token (se terminal)
        self.children = []        # Lista de filhos
\end{lstlisting}

A visualização hierárquica utiliza caracteres especiais para representar a estrutura:

\begin{itemize}
    \item \texttt{├──} para filhos intermediários
    \item \texttt{└──} para último filho
    \item \texttt{│} para linhas verticais de conexão
    \item \texttt{→} para separar símbolo de valor
\end{itemize}

Exemplo de saída:

\begin{verbatim}
S
 ├── program → "program"
 ├── id → "exemplo"
 ├── ; → ";"
 ├── D
 │    ├── var → "var"
 │    └── V
 │         ├── I
 │         │    └── id → "x"
 │         ├── : → ":"
 │         ├── T
 │         │    └── integer → "integer"
 │         └── ; → ";"
 └── begin → "begin"
\end{verbatim}

\subsection{Interface Gráfica}

A interface foi desenvolvida com Tkinter e possui:

\begin{itemize}
    \item \textbf{Painel de controles:} Botões para carregar, analisar e limpar
    \item \textbf{Lista de exemplos:} 5 programas pré-carregados para teste
    \item \textbf{Legenda:} Explicação dos 14 não-terminais
    \item \textbf{Editor de código:} Área para edição do código-fonte
    \item \textbf{Área de resultados:} Exibição da árvore sintática
    \item \textbf{Barra de status:} Indicador visual do estado da análise
\end{itemize}

\section{Resultados}

\subsection{Programas de Teste}

Foram desenvolvidos 5 programas-teste que cobrem todas as construções da linguagem Sigma-. A Tabela 3 apresenta um resumo dos testes:

\begin{table}[h]
\centering
\caption{Programas de Teste Desenvolvidos}
\begin{tabular}{|c|l|l|}
\hline
\textbf{Teste} & \textbf{Nome} & \textbf{Características Testadas} \\
\hline
1 & Programa mínimo & Declarações, atribuições simples \\
2 & Leitura/Escrita & Comandos read/write com strings \\
3 & Condicional & Estrutura if-then-else completa \\
4 & Repetição & Laço while-do com bloco composto \\
5 & Completo & Todas as construções integradas \\
\hline
\end{tabular}
\end{table}

\subsection{Teste 1: Programa Mínimo}

\begin{lstlisting}[caption=Teste 1 - Programa mínimo]
program exemplo;
var x, y : integer;
begin
  x := 10;
  y := x + 20
end.
\end{lstlisting}

\textbf{Resultado:} ✓ Análise concluída com sucesso. Árvore sintática gerada com 47 nós.

\subsection{Teste 2: Leitura e Escrita}

\begin{lstlisting}[caption=Teste 2 - Comandos de I/O]
program io;
var n : integer;
begin
  readln(n);
  writeln("Resultado: ", n)
end.
\end{lstlisting}

\textbf{Resultado:} ✓ Análise concluída com sucesso. Comandos de leitura e escrita processados corretamente.

\subsection{Teste 3: Estrutura Condicional}

\begin{lstlisting}[caption=Teste 3 - If-then-else]
program teste_if;
var n : integer;
begin
  readln(n);
  if n > 0 then
    writeln("positivo")
  else
    writeln("negativo")
end.
\end{lstlisting}

\textbf{Resultado:} ✓ Análise concluída com sucesso. Estrutura condicional completa reconhecida.

\subsection{Teste 4: Estrutura de Repetição}

\begin{lstlisting}[caption=Teste 4 - While-do]
program teste_while;
var i : integer;
begin
  i := 0;
  while i < 10 do
  begin
    writeln(i);
    i := i + 1
  end
end.
\end{lstlisting}

\textbf{Resultado:} ✓ Análise concluída com sucesso. Laço while com bloco composto processado.

\subsection{Teste 5: Programa Completo}

\begin{lstlisting}[caption=Teste 5 - Todas as construções]
program calc;
var a, b, resultado : integer;
begin
  readln(a, b);
  resultado := (a + b) * 2;
  if resultado > 100 then
    writeln("Grande")
  else
    writeln("Pequeno")
end.
\end{lstlisting}

\textbf{Resultado:} ✓ Análise concluída com sucesso. Todas as construções integradas funcionando.

\subsection{Taxa de Sucesso}

\begin{table}[h]
\centering
\caption{Resultados dos Testes}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Categoria} & \textbf{Testes} & \textbf{Taxa de Sucesso} \\
\hline
Programas válidos & 5/5 & 100\% \\
Declarações & 5/5 & 100\% \\
Estruturas de controle & 2/2 & 100\% \\
Expressões aritméticas & 5/5 & 100\% \\
Comandos I/O & 5/5 & 100\% \\
\hline
\textbf{Total} & \textbf{22/22} & \textbf{100\%} \\
\hline
\end{tabular}
\end{table}

\section{Discussão}

\subsection{O Que Foi Implementado}

\subsubsection{Funcionalidades Completas}

\begin{enumerate}
    \item \textbf{Análise Sintática Completa:} Implementação de todos os 14 não-terminais da gramática
    \item \textbf{Árvore de Derivação:} Geração e visualização hierárquica da estrutura sintática
    \item \textbf{Tratamento de Erros:} Mensagens descritivas indicando tipo de erro, token encontrado e posição
    \item \textbf{Interface Gráfica:} Sistema completo com editor, visualizador e controles
    \item \textbf{Precedência de Operadores:} Implementação correta de precedência em expressões
    \item \textbf{Exemplos Integrados:} 5 programas-exemplo pré-carregados
\end{enumerate}

\subsubsection{Funcionalidades Adicionais}

\begin{enumerate}
    \item Numeração de linhas e colunas nos tokens para mensagens de erro precisas
    \item Suporte a comentários delimitados por chaves
    \item Carregamento de arquivos externos
    \item Visualização hierárquica com caracteres de conexão (├──, └──, │)
    \item Indicador visual de status da análise
\end{enumerate}

\subsection{O Que Não Foi Implementado}

\begin{enumerate}
    \item \textbf{Análise Semântica:} Não há verificação de tipos, escopo de variáveis ou declaração antes do uso
    \item \textbf{Geração de Código:} O analisador apenas verifica a sintaxe, não gera código executável
    \item \textbf{Otimizações:} Não há otimização da árvore sintática
    \item \textbf{Tabela de Símbolos:} Não mantém informações sobre variáveis declaradas
\end{enumerate}

\subsection{Limitações da Linguagem}

\subsubsection{Limitações Intencionais (Por Design)}

\begin{enumerate}
    \item Apenas dois tipos de dados: \texttt{integer} e \texttt{boolean}
    \item Não suporta arrays, registros ou ponteiros
    \item Não possui funções ou procedimentos definidos pelo usuário
    \item Não suporta operadores booleanos (\texttt{and}, \texttt{or}, \texttt{not})
    \item Strings apenas em comandos de escrita
\end{enumerate}

\subsubsection{Limitações de Implementação}

\begin{enumerate}
    \item A análise de expressões booleanas é simplificada
    \item Não há verificação de variáveis não declaradas
    \item Não detecta atribuições a variáveis não declaradas
\end{enumerate}

\subsection{Modificações na Gramática}

Foram realizadas as seguintes modificações em relação à gramática original:

\begin{enumerate}
    \item \textbf{Eliminação de recursão à esquerda:} As produções de expressões foram transformadas para permitir análise descendente
    \item \textbf{Fatoração à esquerda:} Algumas produções foram fatoradas para eliminar ambiguidades
    \item \textbf{Simplificações:} Expressões booleanas foram simplificadas mantendo funcionalidade básica
\end{enumerate}

\section{Avaliação do Trabalho}

\subsection{Aspectos Positivos}

\begin{enumerate}
    \item \textbf{Implementação Completa:} Todos os requisitos foram atendidos
    \item \textbf{Interface Intuitiva:} A GUI facilita o uso e visualização dos resultados
    \item \textbf{Código Bem Estruturado:} Separação clara entre léxico, sintático e GUI
    \item \textbf{Documentação Detalhada:} Comentários extensivos no código
    \item \textbf{Testes Abrangentes:} Cobertura completa das construções da linguagem
\end{enumerate}

\subsection{Desafios Encontrados}

\begin{enumerate}
    \item \textbf{Precedência de Operadores:} Requereu transformação da gramática
    \item \textbf{Visualização da Árvore:} Implementação dos caracteres de conexão hierárquica
    \item \textbf{Sincronização:} Garantir que léxico e sintático trabalhem harmoniosamente
    \item \textbf{Tratamento de Erros:} Gerar mensagens informativas e precisas
\end{enumerate}

\subsection{Aprendizados}

\begin{enumerate}
    \item Compreensão profunda de gramáticas livres de contexto
    \item Experiência prática com análise descendente recursiva
    \item Importância do tratamento adequado de erros
    \item Valor de testes sistemáticos e abrangentes
    \item Integração de múltiplos componentes em um sistema coeso
\end{enumerate}

\section{Instalação e Utilização}

\subsection{Requisitos do Sistema}

\begin{itemize}
    \item Python 3.8 ou superior
    \item Tkinter 8.6 (geralmente incluído com Python)
    \item Sistema Operacional: Windows, Linux ou macOS
    \item Memória RAM: Mínimo 2 GB
    \item Espaço em disco: 50 MB
\end{itemize}

\subsection{Instalação}

\subsubsection{Passo 1: Verificar Python}

\begin{lstlisting}[language=bash]
python --version
# Deve exibir Python 3.8 ou superior
\end{lstlisting}

\subsubsection{Passo 2: Extrair Arquivos}

Extraia o arquivo ZIP do projeto para uma pasta de sua escolha.

\subsubsection{Passo 3: Executar o Programa}

\begin{lstlisting}[language=bash]
cd caminho/para/pasta/do/projeto
python analisador_sintatico_sigma.py
\end{lstlisting}

\subsection{Como Utilizar}

\subsubsection{Opção 1: Usar Exemplos Pré-carregados}

\begin{enumerate}
    \item Clique em um dos 5 exemplos listados no painel esquerdo
    \item O código será carregado automaticamente no editor
    \item Clique em ``Analisar Sintaxe''
    \item Visualize a árvore sintática na área inferior
\end{enumerate}

\subsubsection{Opção 2: Carregar Arquivo}

\begin{enumerate}
    \item Clique em ``Carregar Arquivo''
    \item Selecione um arquivo \texttt{.txt} ou \texttt{.sigma}
    \item Clique em ``Analisar Sintaxe''
\end{enumerate}

\subsubsection{Opção 3: Digitar Código}

\begin{enumerate}
    \item Digite ou cole seu código na área de edição
    \item Clique em ``Analisar Sintaxe''
    \item Se houver erros, eles serão exibidos com localização precisa
\end{enumerate}

\subsection{Interpretando os Resultados}

\subsubsection{Análise Bem-Sucedida}

\begin{itemize}
    \item Indicador verde (●) na barra de status
    \item Mensagem: ``Análise sintática concluída com sucesso!''
    \item Árvore sintática exibida na área inferior
    \item Pop-up de confirmação
\end{itemize}

\subsubsection{Erro Sintático}

\begin{itemize}
    \item Indicador vermelho (●) na barra de status
    \item Mensagem de erro descritiva
    \item Indicação da linha e coluna do erro
    \item Sugestão do token esperado
\end{itemize}

\section{Conclusão}

\subsection{Síntese dos Resultados}

Este trabalho apresentou a implementação completa e funcional de um analisador sintático para a linguagem Sigma-, alcançando todos os objetivos propostos. O sistema demonstra a eficácia da técnica de análise descendente recursiva para gramáticas simples e educacionais, fornecendo uma ferramenta útil tanto para aprendizado quanto para validação de programas na linguagem.

Os resultados dos testes indicam que o analisador processa corretamente todas as construções sintáticas da linguagem, gerando árvores de derivação precisas e informativas. A taxa de sucesso de 100\% nos 5 programas-teste validados demonstra a robustez da implementação.

\subsection{Contribuições}

As principais contribuições deste trabalho são:

\begin{enumerate}
    \item \textbf{Implementação Educacional:} Código claro e bem documentado que pode servir como referência para estudantes
    \item \textbf{Interface Gráfica Completa:} Ferramenta visual que facilita compreensão do processo de análise
    \item \textbf{Visualização Hierárquica:} Representação clara da estrutura sintática através de árvores
    \item \textbf{Conjunto de Testes:} 5 programas abrangentes para validação
    \item \textbf{Documentação Detalhada:} Este documento completo descrevendo todos os aspectos do projeto
\end{enumerate}

\subsection{Trabalhos Futuros}

Possíveis extensões e melhorias:

\begin{enumerate}
    \item \textbf{Análise Semântica:} Implementar verificação de tipos e escopo
    \item \textbf{Geração de Código:} Produzir código intermediário ou executável
    \item \textbf{Otimizações:} Implementar otimizações da árvore sintática
    \item \textbf{Extensão da Linguagem:} Adicionar arrays, funções e outros recursos
    \item \textbf{Modo Interativo:} Permitir execução passo-a-passo da análise
    \item \textbf{Exportação:} Gerar árvore em formatos como GraphViz ou JSON
\end{enumerate}

\subsection{Considerações Finais}

O desenvolvimento deste analisador sintático proporcionou compreensão profunda dos conceitos fundamentais de compiladores, especialmente análise sintática e gramáticas livres de contexto. A experiência prática de implementar um parser completo, desde a tokenização até a geração da árvore sintática, consolidou conhecimentos teóricos adquiridos em sala de aula.

A escolha da análise descendente recursiva mostrou-se adequada para a gramática Sigma-, resultando em código limpo, manutenível e fácil de estender. A interface gráfica desenvolvida adiciona valor educacional ao projeto, permitindo visualização clara do processo de análise.

Este trabalho demonstra que, mesmo linguagens simples requerem cuidadosa análise de requisitos, design apropriado e testes abrangentes. As lições aprendidas durante o desenvolvimento - incluindo tratamento de erros, design de gramáticas e importância de documentação - serão valiosas em projetos futuros de maior complexidade.

\section*{Referências}

\begin{enumerate}
    \item AHO, A. V.; LAM, M. S.; SETHI, R.; ULLMAN, J. D. \textit{Compilers: Principles, Techniques, and Tools}. 2nd ed. Boston: Addison-Wesley, 2006.
    
    \item COOPER, K. D.; TORCZON, L. \textit{Engineering a Compiler}. 2nd ed. Morgan Kaufmann, 2011.
    
    \item GRUNE, D.; JACOBS, C. J. H. \textit{Parsing Techniques: A Practical Guide}. 2nd ed. Springer, 2008.
    
    \item LOUDEN, K. C.; LAMBERT, K. A. \textit{Compiler Construction: Principles and Practice}. Cengage Learning, 1997.
    
    \item Python Software Foundation. \textit{The Python Standard Library - Tkinter}. Disponível em: \url{https://docs.python.org/3/library/tkinter.html}. Acesso em: 24 nov. 2025.
    
    \item WIRTH, N. \textit{Compiler Construction}. Addison-Wesley, 1996.
\end{enumerate}

\end{document}
